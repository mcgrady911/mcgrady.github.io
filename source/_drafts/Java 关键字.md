

# Java 关键字
[TOC]

## static
### static 静态变量
声明`static`变量实际上声明了全局变量。
当声明一个`static`变量时，并不产生`static`变量的拷贝，而是所有的实例共用一个`static`变量。
### static静态方法的用途
**static方法就是没有this和super的方法。在static方法内部不能调用非静态方法，反过来可以。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。**

**`方便在没有创建对象的情况下来进行调用（方法/变量）。`**

由于静态方法不依赖于任何对象就可以进行访问，因此对静态方法来说，它是没有`this`的，也由于这个特性，**在静态方法中不能访问类的非静态成员变量/方法**，因为非静态成员方法/变量都是必须依赖具体对象才能够被调用。





## final
### final关键字的基本用法
**`final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。`**

**当final修饰一个类时**，表明这个类不能被继承。因此一个类不能即被声明为`abstract`又被声明为`final`。（final类中所有的成员方法都会被隐式地被指定为final方法，变量同理）

**当final修饰一个方法时**，表明该方法不被任何继承类修改。
(只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final)

**当final修饰一个变量时**，如果是基本数据类型的变量，表明该变量一旦在初始化之后便不能更改；如果是引用类型的变量，则再对其初始化之后便不能再让其指向另一个对象。

### 深入理解final关键字
1. 类的final变了和普通变量有什么区别？
   当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值（局部变量只需要保证在使用之前被初始化赋值即可）。

2. 被final修饰的引用变量指向的对象内容可变吗？
   引用的变量被final修饰之后，不能只想其他对象，但它所指向的对象的内容是可变的。

3. final和static
   `static`作用于成员变量用来表示只保存一份副本，而`final`的作用是用来保证变量不可变。

4. 匿名内部类中使用的外部局部变量为什么只能是final变量？
5. 关于final参数的问题
6. final finally finalize 之间的区别
- **定义的区别**
  `final`： 修饰属性/方法/类，分别表示属性不可变，方法不可覆盖，类不可继承。
  `finally`： 是异常处理语句结构的一部分，表示总是执行（最后）。
  `finalize`：是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。
- **本质的区别**
  `final`：java中的关键字/修饰符。
  `finally`：java中的一种一场处理机制。
  `finalize`：java中的一个方法名。
>`finally`是对java异常处理模型的最佳补充。
>`finally`结构使代码总会执行，而不管有无异常发生。
>使用`finally`可以维护对象的内部状态，并可以清理非内存资源。
>特别是在关闭数据库连接这方面，如果把数据库连接的`close()`方法放到`finally`中，就会大大降低程序出错的几率。
>
>`finalize()`方法是在垃圾收集器删除对象之前对这个对象调用的。





## volatile
Java语言是支持多线程的，为了解决线程并发问题，在语言内部引入了`synchronized`和`volatile`关键字机制。

通常，`volatile`关键字用来阻止（伪）编译器认为的无法“被代码本身”改变的代码（变量/对象）进行优化。





## synchronized
通过`synchronized`修饰的方法或者代码块，在多线程访问的时候，同一时刻只能有一个线程执行该段代码。





## super
在Java类中使用`super`来引用父类的成分，用`this`来引用当前对象。
>`this`是指当前对象的引用，`super`是指当前对象的父对象的引用。

