## Java 知识

### 基础

1. 什么是面向对象（OOP）？
   面向对象编程是使用类，对象，继承性，多态性，封装性和抽象的一种程序设计方法。

2. 什么是多态？实现多态的机制是什么？

   - 允许将子类类型的指针赋值给父类类型的指针，把不同的子类对象都当作父类来看。

   - 我们在程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用在编程的时候并不确定，当处于运行期间才确定。就是这个引用变量究竟指向哪一个实例对象，在编译期间是不确定的，只有运行期才能确定，这样不用修改源码就可以把变量绑定到不同的类实例上，让程序拥有了多个运行状态，这就是多态。
     - 编译时多态：比如重载
     - 运行时多态：比如重写
   - 多态的实现机制：父类或者接口定义的引用变量可以指向子类或者具体实现类的实例对象，由于程序调用方法是在运行期才动态绑定的，那么引用变量所指向的具体实例对象在运行期才确定。所以这个对象的方法是运行期正在内存运行的这个对象的方法而不是引用变量的类型中定义的方法。
     

3. 接口（Interface）与抽象类（Abstract Class）的区别？

   - 抽象类是一个可同时包含具体方法和抽象方法(方法未被实现)的类。抽象方法必须被该抽象类的子类实现。抽象类是可以继承的。
   - 接口像是描述类的一张蓝图或者说是类的一种契约，它包含了许多空方法，这代表着它的所有的子类都应该拥有共同点。它的子类应该提供这些空方法的具体实现。一 个类需要用 implements 来实现接口，接口可以用 extends 来继承其他接口。
     

4. 重写（Override）与重载（Overload）的区别？

   - 覆盖是子类与父类之间的关系，是一种垂直关系；重载是同一个类中方法之间的关系，是水平关系
   - 覆盖要求参数列表要相同；重载要求参数列表不同
     

5. 静态属性和静态方法是否可以被继承？是否可以被重写？为什么？

   - 父类的静态属性和方法可以被子类继承
   - 严格来说，不存在静态方法的重写，当一个子类继承父类时，写同样的方法时，只是将父类的静态方法隐藏。
   - 原因：静态方法是类在加载时就被加载到内存中的方法，在整个运行过程中保持不变，因而不能重写。
     

6. 什么是内部类？内部类、静态内部类、局部内部类和匿名内部类的区别及作用？
   ![java_class](..\images\java\java_class.png)

   - 内部类：可以将一个类定义在另一个类或方法里面的类称为内部类。

   - 静态内部类：静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法。

     ```java
     public class OuterClass {
         private String name;
         
         public static class StaticInerClass {
             private String name;
         }
     }
     
     OuterClass.StaticInerClass staticInser = new OuterClass.StaticInerClass();
     ```

     

   - 局部内部类：局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。

   - 匿名内部类：匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。

     ```java
     button.setOnClickListener(new OnClickListener() {
         @Override
         public void onClick(View v) {
             // TODO
         }
     });
     ```

7. 类的加载过程？
   - 加载 loading
   - 验证 verification
   - 文件格式验证
   - 准备 preparation
   - 解析 resolution
   - 初始化 initialization
     

8. == 和 equals() 和 hashCode() 的区别？

   - `==`：对于基本类型（byte,short,char,int,long,float,double,boolean）比较的是他们的值;对于引用类型(类、接口、数组)   ：比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。
   - `equals()`：默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。
   - `hashCode()`：实际上返回的就是对象存储的物理地址，hashcode方法只有在集合中用到。

9. Integer 和 int 之间的区别？

   - Integer是int的包装类，int则是Java的一种基本数据类型。
   - Integer变量必须实力会啊后才能使用，而int变量不需要。
   - Integer实际上是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则直接存的是数值。
   - Integer默认值是null，int默认值是0。
     

10. String 转换成 Integer 的方式及原理？

  ```java
  //内部调用Integer.valueOf(parseInt(s, 10))
  Integer num = Integer.valueOf("127");
  /*内部调用parseInt(String, int) 
  首先检查第一个字符是否为符号位，然后默认采用10进制循环遍历每个字符，
  通过*=和-=进行计算拼接，最后判断是否为负数再返回结果。
  Character.digit(char ch, int radix)返回指定基数中字符表示的数值。*/
  Integer num2 = Integer.parseInt("127");
  ```

  

11. 自动装箱实现原理？类型转换实现原理？

    - 自动装箱：自动装箱时编译器调用`valueOf`将原始类型值转换成对象，`valueOf`内部判断值是否特定的范围内，是则冲缓存策略中获取，否则`new`一个新的包装类。使用缓存策略是因为缓存一些经常使用数值，防止每次自动装箱都创建相同的实例。
    - 类型转换：自动类型转换通过提升数据类型计算结果。（只能自动提升不能自动降低）
      

12. 对 String 的了解？

    - String类是final类，意味着String不能被继承，且类中的成员方法都默认为final方法。
    - String类其实是用过char[]数组来保存字符串的。
    - String对象一旦被创建就是固定不变的，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象。
      

13. String 为什么要设计成不可变的？
    为了提高性能和减少内存的开销，避免常量池中不会存在两个相同的字符串。

14. final、finally 和 finalize 的区别？

    - final：可以用来修饰类，方法和变量，当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰。
    - finally：作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。
    - finalize：是在`java.lang.Object`里定义的方法，每一个对象都有这么个方法。这个方法在`gc`启动，该对象被回收的时候被调用。
      

15. static 关键字有什么作用？

    - 修饰成员变量，将其变为类的成员，从而实现所有对想想对该成员的共享。
    - 修饰成员方法，将其变为类方法，可以直接使用`Class.fun`的方式调用，常用于工具类。
    - 修饰为静态代码块，将多个类成员放在一起初始化，使程序更加规整。
    - 静态导包，将类的方法直接导入当前类中，从而直接使用方法名即可调用类方法。
      

16. 列举 Java 的集合以及集合之间的继承关系？
    ![java集合继承关系](..\images\java\java集合继承关系.png)
    ![java集合框架结构](..\images\java\java集合框架结构.gif)

17. List、Set、Map 的区别？

    - List：有序可重复。有索引
    - Set：无序不可重复
    - Map：键值对集合
      

18. ArrayList、LinkedList 的区别？

    - ArrayList是基于动态数组的结构，LinkedList是基于双向链表的结构。
    - 对于改查数据，ArrayList优于LinkedList，因为LinkedList需要移动指针。
    - 对于增删数据，LinkedList优于ArrayList，因为ArrayList需要移动数据。
      

19. HashMap，HashTable，ConcurrentHashMap 实现原理以及区别？

20. HashSet 与 HashMap 怎么判断集合元素重复？

21. String、StringBuffer、StringBuilder 之间的区别？
    ![string关系图](..\images\android\string关系图.webp)

    - String：字符串常量
    - StringBuffer：字符串变量，线程安全
    - StringBuilder：字符串变量，线程非安全
    - 运行速度：StringBuilder > StringBuffer > String
      

22. 什么是序列化？怎么实现？有哪些方式？

    - 序列化：是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化（将对象转换成二进制）。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。 
    - 序列化的实现：将需要被序列化的类实现`Serializable`接口，系统会标注该对象是可被序列化的，然后使用输出流（例如：`FileOutputSteam`）构造一个流对象`ObjectOutputStream`，使用`.writeObject(Object obj)`可将`object`对象输出；相反的话则用输入流。
    - 实现序列化的方式：（性能由低至高）
      - Java Serialization
      - Json
      - FastJson
      - Hession
      - Dubbo
      - FST
      - Kryo
        

23. 对反射的了解？
    Java提供的在运行时可识别对象和类信息的方式有两种：

    - RTTI：编译器再编译时打开和检查`.class`文件
    - 反射：运行时打开和检查`.class` 文件
      

24. 对注解的了解？

    - **定义**：注解提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序元素加上更直观的说明，起到了辅助性的作用，这些说明信息与程序的业务逻辑无关，并供指定的工具或框架使用。
      - 元注解
      - 运行时注解
      - 编译时注解
    - **原理**：注解本质是一个继承了 `Annotation` 的特殊接口，其具体实现类是 Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是 Java 运行时生成的动态代理对象 `$Proxy1`。通过代理对象调用自定义注解（接口）的方法，会最终调用 `AnnotationInvocationHandler` 的 `invoke()` 方法。该方法会从 `memberValues` 这个 Map 中索引出对应的值。而 `memberValues` 的来源是 Java 常量池。
    - **作用**：
      - 自动完成一些规律性的代码，实现替代配置文件
      - 编译时进行格式检查
        

25. 对依赖注入的了解？

    - 举例：Android Annotation、ButterKnife、Dagger2
    - 作用：
      - 依赖注入降低了依赖和被依赖类型间的耦合，在修改被依赖的类型实现时，不需要修改依赖类型的实现。
      - 为什么要有依赖注入，因为我们要控制反转（设计代码的思路）。为什么控制反转。因为我们软件设计需要符合软件设计原则依赖倒置（设计代码原则），单一职责原则。
        

26. 对泛型的了解？
    泛型的本质是参数化类型，也就是说所操作的数据类型被指定为某个参数类型。
    这种参数类型可以在类、接口和方法中创建，分别称为泛型类、泛型接口、泛型方法。

27. 泛型中 extends 和 super 的区别？

28. 对 Java 的异常体系的了解？

29. 对解析与分派的了解？

30. 静态代理和动态代理的区别？有什么场景使用？

31. 谈谈对 Java 状态机理解？

32. Exception和Error的区别？

33. Java 7 和 Java 8的区别？

    - Java 8
      - lambda 表达式
        

### 线程与并发

1. 线程和进程的区别？

   - 一个程序至少有一个进程，一个进程至少有一个线程
   - 进程在执行过程中拥有独立的内存单元，而多个线程共享内存
     

2. 开启线程的三种方式？

   ```java
   new Thread(new Runnable() {
       @Override
       public void run() {
           //TODO
       }
   }).start();
   
   Runnable runnable = new Runnable() {
       public void run() {
           //TODO
       }
   };
   Handler handler = new Handler();
   handler.post(runnable);
   handler.removeCallbacks(runnable);
   ```

   

3. 如何正确的结束一个Thread？
   `Thread.interrupt();`

4. Thread 与 Runnable 的区别？

   - 资源共享，适合多个相同的线程处理同一个资源
   - 可以避免Java中的单继承限制
   - 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
     

5. run() 与 start() 方法的区别？

   - start()：通过调用`start()`方法开启一个线程，这时线程处于就绪状态，并没有运行，一旦得到CPU时间片，就开始执行`run()`方法，`run()`方法运行结束，线程随即终止。
   - run()：`run()`只是Thread的普通方法而已，在Thread开启之后由Java虚拟机直接调用。
     

6. sleep() 与 wait() 方法的区别？

   - sleep()：属于Thread中的方法，使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用，单他的监控状态依然保持，当指定的时间结束后自动恢复运行状态，在唤醒之后不保证立即或者到CPU，它会先进入就绪状态，与其他线程竞争CPU。
   - wait()：属于Object中的方法，必须在`synchronized`环境下使用，否则会抛出`IllegalMonitorStateException`异常。`wait()`执行了之后，需要额外的方法`notify()` `notifyAll()`唤醒；`wait()`总是在一个循环中被调用，挂起当前线程来等待一个条件的成立。
   - 共同点：都需要捕获`InterruptedException`异常
     

7. wait 与 notify 关键字的区别？

8. synchronized 关键字的用法、作用及实现原理？

   - 用法：

     ```java
     public class Test {
         
         public void test1() {
             synchronized(this) {
                 //TODO
             }
         }
         
         public synchronized void test2() {
             //TODO
         }
         
     }
     ```

   - 作用：用于实现多线程的同步操作
     - 对于添加了`synchronized`关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。
     - 当作用在静态方法时锁住的便是对象对应的类实例，保证共享变量的修改能够及时可见。
     - 
   - 原理：基于进入和退出Monitor对象实现。
     

9. `synchronized(this)`与`synchronized(object)`锁住的是什么？
   锁住的是当前对象，当`synchronized`块里的内容执行完之后，释放当前对象的锁。同一时刻若有多个线程访问这个对象，则会被阻塞。

10. volatile 关键字的用法、作用及实现原理？

11. transient 关键字的用法、作用及实现原理？

12. ReentrantLock、synchronized、volatile 之间的区别？

13. 什么是线程池，如何使用？

14. 多线程断点续传的实现原理？

15. 什么是深拷贝和浅拷贝？

16. Java 中对象的生命周期？

17. 对并发编程的了解？

### JVM

1. 简述 JVM 内存模型和内存区域？
2. 简述垃圾回收器的工作原理？
3. 如何判断对象的生死？垃圾回收算法？新生代，老生代？
4. 哪些情况下的对象会被垃圾回收机制处理掉？
5. 垃圾回收机制与调用 System.gc() 的区别？
6. Java中引用类型的区别，具体的使用场景？
   - 强引用：强引用指的是通过new对象创建的引用，垃圾回收器即使是内存不足也不会回收强引用指向的对象
   - 软引用：软引用是通过SoftRefrence实现的，它的生命周期比强引用短，在内存不足，抛出OOM之前，垃圾回收器会回收软引用引用的对象。软引用常见的使用场景是存储一些内存敏感的缓存，当内存不足时会被回收。
   - 弱引用：弱引用是通过WeakRefrence实现的，它的生命周期比软引用还短，GC只要扫描到弱引用的对象就会回收。弱引用常见的使用场景也是存储一些内存敏感的缓存。
   - 需引用：虚引用是通过FanttomRefrence实现的，它的生命周期最短，随时可能被回收。如果一个对象只被虚引用引用，我们无法通过虚引用来访问这个对象的任何属性和方法。它的作用仅仅是保证对象在finalize后，做某些事情。虚引用常见的使用场景是跟踪对象被垃圾回收的活动，当一个虚引用关联的对象被垃圾回收器回收之前会收到一条系统通知。
     

7. 强引用设置为 null，会不会被回收？
8. 简述 ClassLoader 类加载机制？
9. 对双亲委派模型的了解？
10. String a = "a"+"b"+"c" 在内存中创建几个对象？
  1个对象，`javac`会进行常量折叠，全字面量字符串相加是可以折叠为一个字面常量，而且是进入常量池的。通过编译器优化后，得到的效果是：`String a = "abc"`

11. 对 Dalvik、ART 虚拟机的了解？
    - Dalvik是Google公司自己设计用于Android平台的虚拟机；它可以支持已转换为 `.dex`（即Dalvik Executable）格式的Java应用程序的运行，`.dex`格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。
      - Dalvik基于寄存器，JVM基于栈
      - Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行
      - Dalvik运行的是其专有的文件格式`.dex`，而JVM运行的是Java字节码
      - `.dex`文件格式可以减少整体文件大小，提高I/O操作的类查找速度
      - odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化
      - 为简化翻译，常量池只使用32位索引
    - ART是Google采用取代了以往的Dalvik虚拟机
      - Dalvik采用的是JIT技术，而ART采用的是AOT技术
      - 提高了垃圾回收率
      - 提高了内存使用率、减少了内存碎片化
      - Dalvik虚拟机执行的是dex字节码，ART虚拟机执行的是本地机器码
      - ART更大的占用存储空间，更长的应用安装时间，总的来说就是“空间换时间”
        

12. 对动态加载（OSGI）的了解？
13. 常见编码方式有哪些？
    - ASCII
    - GBK
    - UTF-8
    - UTF-16
    - GB2312
      

14. UTF-8 编码中的中文占几个字节？
    - 一个UTF-8数字占1个字节
    - 一个UTF-8英文字母占1个字节
    - 少数UTF-8汉字占3个字节，多数占4个字节
      

15. Java基本数据类型

| 类型    | 占用字节 | 占用位数 | 取值范围                       |
| ------- | -------- | -------- | ------------------------------ |
| byte    | 1个字节  | 8位      | -128~127                       |
| short   | 2个字节  | 16位     | -32768 ~ 32767                 |
| int     | 4个字节  | 32位     | -2,147,483,648 ~ 2,147,483,647 |
| long    | 8个字节  | 8        | -2^63 ~ 2^63 -1                |
| float   | 4个字节  | 32位     |                                |
| double  | 8个字节  | 64位     |                                |
| char    | 2个字节  | 16位     |                                |
| boolean | 1个字节  |          | true ~ false                   |



## Android 知识

### 基础

1. 四大组件是什么？

   - Activity
   - Service
   - Boradcast
   - ContentProvider
     

2. Activity 的生命周期？

   ![activity_life](..\images\android\activity_life.png)
   


3. Activity 之间的通信方式？

   - Bundle
   - ShardPefres
   - SQLite
   - 全局静态变量
     

4. Activity 各种情况下的生命周期？

   - 横竖屏切换时 Activity 的生命周期

     ```java
     //切换横屏时，竖屏的状态
     onPause()→onSaveInstanceState()→onStop()→onDestory()
     //切换到横屏状态
     onCreate()→onStart()→onRestoreInstanceState()→onResume()
     //再切回竖屏状态
     ```

   - 弹出 Dialog 的时候按 Home 键时 Activity 的生命周期

     ```java
     onCreate()→onStart()→onResume→onPause()→onStop() 
     ```

     我们弹出的AlertDialog对话框实际上是Activity的一个组件，Activity并没有进入后台，AlertDialog实际上是一个布满全屏的组件，当我们点击了Home键后Activity才真正地进入后台工作。

   - 两个 Activity 之间跳转时的生命周期

     ```java
     //Activity1启动Activity2
     Activity1→onPause()
     Activity2→onCreate()→onStart()→onResume()
     Activity1→onStop()
     //Activity2返回Activity1
     Activity2→onPause()
     Activity1→onRestart()→onStart()→onResume()
     Activity2→onStop()→onDestory()
     ```

   - 下拉状态栏时 Activity 的生命周期
     不影响Activity生命周期

5. Activity 的四种 LaunchMode（启动模式）的区别？应用场景？
   ![Activity启动模式](..\images\android\Activity启动模式.png)

   - SingleTask模式运用场景
     最常见的应用场景就是保持我们应用开启后仅仅有一个Activity的实例。最典型的样例就是应用中的Home主页。
   - SingleTop模式运用场景
     假设你在当前的Activity中又要启动同类型的Activity，此时建议将此类型Activity的启动模式指定为SingleTop，能够降低Activity的创建，节省内存！
   - SingleInstance模式运用场景
     

6. Activity 状态保存与恢复？

7. Fragment 的生命周期？Fragment Activity 与 之间生命周期的比较？
   ![fragment生命周期](..\images\android\fragment生命周期.png)![activity_fragment_生命周期对比](..\images\android\activity_fragment_生命周期对比.png)




8. Fragment 各种情况下的生命周期？

   - Activity调用`replace()`方法时Fragment的生命周期

     ```java
     //新替换的Fragment
     onAttach()→onCreate()→onCreateView()→onViewCreated()→onActivityCreated()→onStart()→onResume()
     // 被替换的Fragment
     onPause()→onStop()→onDestroyView()→onDestroy()→onDetach()
     ```

   - Activity调用`replace()`方法,并`addToBackStack()`时Fragment的生命周期

     ```java
     //新替换的Fragment（没在BackStack中）
     onAttach()→onCreate()→onCreateView()→onViewCreated()→onActivityCreated()→onStart()→onResume()
     //新替换的Fragment（已在BackStack中）
     onCreateView()→onViewCreated()→onActivityCreated()→onStart()→onResume()
     //被替换的Fragment
     onPause()→onStop()→onDestroyView()→onDestroy()
     ```

   - Fragment在ViewPager中切换

     

9. Activity 和 Fragment 之间怎么通信， Fragment 和 Fragment 又怎么通信？

  - 获取实例通过暴露的公共方法
  - 使用广播的方式
  - 通过接口的方式
    

10. Service 的生命周期？
  ![android_service生命周期](..\images\android\android_service生命周期.png)

11. Service 的启动方式？以及它们之间的区别？

    - `startService()`
      启动Service时会经历：`onCreate()` →`onStartCommand()`；多次调用`startService()`，`onCreate()`只会执行一次，`但onStartCommand()`每次都会执行。
      如果你只是想要启动一个后台服务长期进行某项任务，那么使用`startService`便可以了。
    - `bindService()`
      绑定Service时会经历：`onCreate()`→`onBind()`；多次调用`bindService()`时`onCreate()`和`onBind()`不会被调用多次。且Service不会多次创建和绑定。
      如果启动一个后台服务长期进行某项任务，且与正在运行的Service取得联系，那么有两种方法：一种是使用`Broadcast`，另一种是使用`bindService`。

12. Service 与 IntentService 的区别？
    IntentService是继承并处理异步请求的一个类，在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统的Service一样，同时，当任务执行完后，IntentService会自动停止，而不需要我们手动去控制或stopSelf()。另外，可以启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行，并且，每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。

13. Service 和 Activity 之间的通信方式？

    - 通过Binder对象，使用ServiceConnection进行关联
      Activity调用`bindService (Intent service, ServiceConnection conn, int flags)`方法，得到Service对象的一个引用，这样Activity可以直接调用到Service中的方法，如果要主动通知Activity，可以利用回调方法。
    - 通过Broadcast广播的方式
      比如Service要向多个Activity发送同样的消息的话，用这种方法就更好，当然Activity要注册相应的接收器。

14. Service是否在主线程中执行？Service里可以执行耗时操作吗？
    Service是跑在主线程中，所以的耗时操作还是要开启线程来执行。

15. Service里可以弹Toast吗？
    可以，通过`getApplicationContext()`获取上下文实例即可

    ```java
    Handler handlerThree = new Handler(Looper.getMainLooper());
    handlerThree.post(new Runnable() {
        public void run() {
            Toast.makeText(getApplicationContext() ,"",Toast.LENGTH_LONG).show();
        }
    });
    ```

    

16. 对 ContentProvider 的理解？

17. ContentProvider、ContentResolver、ContentObserver 之间的关系？

18. 对 BroadcastReceiver 的了解？

    - `onReceive()`中不能执行耗时操作，如果耗时超过10s会弹出ANR
    - `onReceive()`中Context参数，如果是静态注册的广播，Context为`ReceiverRestrictedContext`，如果要启动一个Activity的话，需要在Intent中添加`Intent.FLAG_ACTIVITY_NEW_TASK`；如果是动态注册的广播，Context为当前注册时所在的组件，比如Activity或者Service。
    - 监听系统广播，需要在AndroidManifest中申请权限，此外，Android高版本系统对于一些重要的系统广播，比如开机启动，网络连接，电量变化，锁屏等做了限制，如果需要监听这些广播，需要做系统兼容性处理。
    - 普通广播的广播接收器是并行无序执行的，有序广播的广播接收器按照广播优先级串行执行。
      

19. 广播的分类？使用方式和场景？

    - App全局监听，这种主要用于在`AndroidManifest`中静态注册的广播接收器，一般我们在收到该消息后，需要做一些相应的动作，而这些动作与当前App的组件，比如Activity或者Service的是否运行无关，比如我们在集成第三方`Push SDK`时，一般都会添加一个静态注册的`BroadcastReceiver`来监听`Push`消息，当有`Push`消息过来时，会在后台做一些网络请求或者发送通知等等。
    - 组件局部监听，这种主要是在Activity或者Service中使用`registerReceiver()`动态注册的广播接收器，因为当我们收到一些特定的消息，比如网络连接发生变化时，我们可能需要在当前Activity页面给用户一些UI上的提示，或者将Service中的网络请求任务暂停。所以这种动态注册的广播接收器适合特定组件的特定消息处理。
      

20. 动态广播和静态广播有什么区别？

    - 动态注册广播不是常驻型广播，跟随Activity的生命周期；静态注册是常驻型，当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。
    - 动态注册比静态注册安全
    - 静态广播在App启动时初始化；动态广播使用代码初始化
    - 动态广播的优先级比静态广播高
      

21. 进程间通信的方式有哪几种？

    - AIDL
    - 广播
    - 文件
    - Socket
      

22. 线程间通信的方式有哪几种？

23. AlertDialog、PopupWindow 之间的区别？

    - 不同点：
      - PopWin在显示之前一定要设置宽高，Dialog无此限制
      - PopWin默认不会响应物理键盘的back，除非显示设置了`popup.setFocusable(true)`；而在点击back的时候，Dialog会消失
      - PopWin不会给页面其他的部分添加蒙层，而Dialog会
      - PopWin没有标题，Dialog默认有标题，可以通过`dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);`取消标题
    - 共同点：
      - 二者显示的时候都要设置Gravity，如不设置，Dialog默认是`Gravity.CENTER`
      - 二者都有默认的背景，都可以通过`setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));`去掉。
    - AlertDialog是**非阻塞式**对话框，AlertDialog弹出时，后台还可以做其他事情；而PopWin是**阻塞式**对话框，PopWin弹出直至PopWin推出前，程序会一直等待，等待`dismiss`方式执行后，程序才会想下执行。
      

24. Application 和 Activity 的 Context 之间的区别？
    Context是Activity Application Service 的抽象基类

    - ApplicationContext 与ActivityContext的生命周期不一样
    - 一般会使用静态的方法并且使用单例。很多时候需要传Context，一般这个时候当static是一个强引用，使用Activity的时候当Activity销毁的时候，Context的引用无法被回收 导致类存泄露。
    - 创建activity或者图片或者组件的创建，应该使用Activity的Context，不然因为Application是全局的导致这些资源无法及时得到释放，导致内存泄露。
      

25. Android 动画分类，以及特性？

    - 补间动画
      包括移动、渐变、伸缩、旋转，一般是定义在`res-anim`这个资源文件夹下，然后`res-style`中定义这个动画。

      ```xml
      <style name="Anim_Pop_TopOrBotom">
          <item name="android:windowEnterAnimation">@anim/pop_in_bottom_to_top</item>
          <item name="android:windowExitAnimation">@anim/pop_out_top_to_bottom</item>
      </style>
      ```

    - 逐帧动画

    - 属性动画
      Android3.0之后增加的特性，用来在特定的时间修改对象的属性，例如背景颜色和alpha等，可定义在`res-animator`资源文件中。

      ```xml
      <set android:ordering=["together" | "sequentially"]]]>  
          <objectAnimator  
              android:propertyName="string"  
              android:duration="int"  
              android:valueFrom="float | int | color"  
              android:valueTo="float | int | color"  
              android:startOffset="int"  
              android:repeatCount="int"  
              android:repeatMode=["repeat" | "reverse"]  
              android:valueType=["intType" | "floatType"]/>  
          <animator  
              android:duration="int"  
              android:valueFrom="float | int | color"  
              android:valueTo="float | int | color"  
              android:startOffset="int"  
              android:repeatCount="int"  
              android:repeatMode=["repeat" | "reverse"]  
              android:valueType=["intType" | "floatType"]/>  
        
          <set]]>  
              ...  
          </set>  
      </set> 
      ```

      

26. 请列举 Android 中常见的布局（Layout）类型，并简述其用法，以及排版效率。【猎豹移动】 LinearLayout、RelativeLayout、FrameLayout 的特性对比及使用场景？

27. 对 SurfaceView 的了解？

28. Serializable 和 Parcelable 的区别？

    - Serializable：是Java的序列化API，Serializable使用IO读写存储在硬盘上。序列化过程使用了反射技术，并且期间产生临时对象。优点代码少，实现容易。
    - Parcelable：是Android的序列化API，它的出现是为了解决Serializable在序列化的过程中消耗资源严重的问题；Parcelable是直接在内存中读写，性能上要优于Serializable。但是代码写起来相比Serializable方式麻烦一些。，一般只获取内存数据的时候使用。
      

29. Android 中数据存储方式有哪些？

    - SharedPreferences
    - File
    - SQLite
    - ContentProvider
    - 网络
      

30. 屏幕适配的处理技巧都有哪些？

31. Android 各个版本 API 的区别？

    - KitKat（Android 4.4/API 19）

      - 沉浸式全屏模式
      - 透明系统状态栏
    - Lollipop（Android 5.0/API 21）

      - Meaterial Design
      - 安装时控制权限
      - RecyclerView/CardView/DrawerLayout/SwipeRefreshLayout/ToolBar
      - 可自定义状态栏、标题栏、导航栏颜色、控件阴影
    - Marshmallow（Android 6.0/API 23）

      - 动态权限
    - Nougat（Android 7.0/API 24）
      - 低耗电模式
      - 后台优化
    - Oreo（Android 8.0/API 26）
      - 自适应图标
      - Notification Channels
    - Pie（Android9.0/API 28）
      - 对全面屏（刘海屏）的支持
      - 神经网络
      - Material Design 2.0
        

32. 动态权限适配方案，权限组的概念？

33. 为什么不能在子线程更新 UI？

34. ListView 图片加载错乱的原理和解决方案？

35. 对 RecycleView 的了解？

36. Recycleview 和 ListView 的区别？

37. RecycleView 实现原理？

38. AndroidManifest 的作用与理解？

39. 多线程在 Android 中的使用？

40. 区别 Animation 和 Animator 的用法，概述实现原理？【猎豹移动】

41. SpannableString 与 SpannableStringBuilder的区别？

    - SpannableString 长度不可变
    - SpannableStringBuilder 长度可变
      

### 进阶

1. 画出 Android 的大体架构图
   ![android构架图](..\images\android\android构架图.png)

2. 低版本 SDK 如何使用高版本 API？

   - @TargetApi：忽略特定版本的API调用报错。

     ```java
     @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public void fun() {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
             // 此时我们正常使用API 9的方法，如果这里误使用了Api 11中的方法，编译时就会报错
             // 提醒我们只是引入API 9中的方法
         } else {
             // TODO 使用老的方式
         }
     }
     ```

   - @SuppressLint：使用`@SuppressLint("NewApi")`的方式让Lint在编译时忽略所调用API对版本的要求。

     ```java
     @SuppressLint("NewApi")
     public void fun() {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
             // 此时我们正常使用API 9的方法，如果这里误使用了Api 11中的方法，编译时就会报错
             // 那么运行在低版本中将会引发Crash的风险
         } else {
             // TODO 使用老的方式
         }
     }
     ```

   - 总结：使用上面两种注释的方式只是让lint在编译时不再报错，在低版本的手机系统中，如果直接使用高版本的API肯定会报：`NoSuchMethod`的Crash的。所以正确的做法应该是在注解的方法中，做版本判断，在低版本中依然使用老的方式处理。版本判断时我们需要判断具体的版本号，`@TargetApi`的方式比较安全。
     

3. AsyncTask 如何使用？

   ```java
   class DownloadTask extends AsyncTask<String, Object, Long> {
   
      //运行在UI线程中，在调用doInBackground()之前执行
       @Override
       protected void onPreExecute() {
           super.onPreExecute();
           Log.d(TAG, "开始下载...");
       }
   
       @Override
       protected Long doInBackground(String... params) {
           //totalByte表示所有下载的文件的总字节数
           long totalByte = 0;
           //params是一个String数组
           for(String url: params){
               //遍历Url数组，依次下载对应的文件
               Object[] result = downloadSingleFile(url);
               int byteCount = (int)result[0];
               totalByte += byteCount;
               //在下载完一个文件之后，把阶段性的处理结果发布出去
               publishProgress(result);
               //如果AsyncTask被调用了cancel()方法，那么任务取消，跳出for循环
               if(isCancelled()){
                   break;
               }
           }
           //将总共下载的字节数作为结果返回
           return totalByte;
       }
   
       //显示线程任务执行的进度
       @Override
       protected void onProgressUpdate(Object... values) {
           super.onProgressUpdate(values);
           Log.i(TAG, "内容 " + values[1] + "下载完成，共" + values[0] + "字节");
       }
   
       //接收线程任务执行结果、将执行结果显示到UI组件
       @Override
       protected void onPostExecute(Long aLong) {
           super.onPostExecute(aLong);
           Log.i(TAG, "全部下载完成，总共下载了" + aLong + "个字节);
       }
   
       //将异步任务设置为：取消状态
       @Override
       protected void onCancelled() {
           super.onCancelled();
           Log.i(TAG, "取消下载");
       }
   }
                     
   DownloadTask downloadTask = new DownloadTask();
   downloadTask.execued();
   ```

   

4. AsyncTask 机制、原理及不足？

5. 如果在 onStop() 的时候做了网络请求，onResume() 的时候怎么恢复？

6. Handler 机制和底层实现？

   - Handler
     每个Handler都会跟一个线程绑定，并与该线程的MessageQueue关联，从而实现消息的管理以及线程间通信。
   - Looper
   - MessageQueue
     MessageQueue是一个消息体对象的无界的单向链表集合，它按照时序将消息插入队列，最小的时间戳将会被首先处理。
   - Message
   - Runnable
     

7. Handler、Thread、HandlerThread 区别？ Thread、Looper、MessageQueue、Handler、Message，每个类的功能是什么，这些类之间是什么关系？【猎豹移动】

8. ThreadLocal 原理、实现及如何保证 Local 属性？

9. 自定义 View 的流程？如何机型适配？

10. 自定义 View 的时怎么获取 View 的大小？

11. View 的绘制流程？

12. View 的事件传递分发机制？

13. requestLayout()，onLayout()，onDraw()，drawChild() 区别与联系？

14. invalidate() 和 postInvalidate() 的区别？

15. 如何计算一个 View 的嵌套层级？

16. Android 动画框架及实现原理？

17. 进程和 Application 的生命周期的关系？

18. SpareArray 的实现原理？

19. SharedPreferences 的实现原理？是否进程同步？如何做到同步？

20. ContentProvider 是如何实现数据共享的？

21. ContentProvider 的权限管理？

22. Android 系统为什么会设计 ContentProvider？

23. Android 线程有没有上限？
    没有，android系统对应用程序资源的限制仅仅是以进程为单位，资源都限制在这个进程里，开多少线程用的都是进程里的资源。

24. Android 中开启摄像头的主要流程？

25. 对 Bitmap 对象的了解？

26. 图片加载原理？

27. 图片压缩原理？

28. 图片框架实现原理？LRUCache 原理？

29. EventBus 实现原理？

30. ButterKnife 实现原理？

31. Okhttp 实现原理？

32. 服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？

33. SQLite 数据库升级，数据迁移问题？

34. 数据库框架对比和源码分析？

35. CAS介绍，OAuth 授权机制？

36. 谈谈你对安卓签名的理解

37. App 是如何沙箱化，为什么要这么做？



### 混合开发

1. 混合开发的方式？各自优缺点和使用场景？
2. Hybird
3. React Native
4. Weex
5. Flutter
6. Dart
7. 快应用



### Framework

1. 请介绍一下 NDK？
   Native Developer Kit

2. 如何加载 ndk 库？如何在 jni 中注册 native 函数，有几种注册方式？【猎豹移动】

3. Android 进程分类？

4. 谈谈对进程共享和线程安全的认识？

5. 谈谈对多进程开发的理解以及多进程应用场景？

6. 什么是协程？

7. 逻辑地址与物理地址，为什么使用逻辑地址？

8. Android 为每个应用程序分配的内存大小是多少？

9. 进程保活的方式？

10. 系统启动流程是什么？
  ![Android系统启动流程](..\images\android\Android系统启动流程.jpg)

11. 一个应用程序安装到手机上的过程发生了什么？

12. App 启动流程，从点击桌面开始（Activity 启动流程）？

13. 什么是 AIDL？解决了什么问题？如何使用？
    AIDL（Android Interface Definition Language）是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。实际上实现跨进程之间通信的有很多，
    比如广播，Content Provider，但是AIDL的优势在于速度快(系统底层直接是共享内存)，性能稳，效率高，一般进程间通信就用它。

14. Binder 机制及工作原理？
    Binder基于`Client-Server`通信模式，传输过程只需一次拷贝，为发送发添加`UID/PID`身份，既支持实名Binder也支持匿名Binder，安全性高；出于安全性考虑Android建立一套新的`IPC`机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。

15. App 中唤醒其他进程的实现方式？

16. Activity、Window、View 三者的关系与区别？

    - Activity 控制单元
    - Window 承载模型
    - View 显示视图

    Activity在`onCreate`中调用attach方法，在attach方法中创建一个window对象。window对象创建时并没有创建DocerView对象，而是当用户在Activity中调用`setContentView`方法之后，接着转到Window的`setContentView`，这时会检查DecorView是否存在，如果不存在则创建`DecorView`对象，然后把用户自己的View添加到DecorView中。

17. ApplicationContext 和 ActivityContext 的区别？

18. ActivityThread，ActivityManagerService，WindowManagerService 的工作原理？

19. PackageManagerService 的工作原理？

20. PowerManagerService 的工作原理？

21. 权限管理系统（底层的权限是如何进行 grant 的）？

22. 操作系统中进程和线程有什么区别？系统在什么情况下会在用户态和内核态中切换？【猎豹移动】

23. 如果一个 App 里面有多个进程存在，请列举你所知道的全部 IPC 方法。

### 性能优化

1. 如何对 Android 应用进行性能分析以及优化？

   - **应用UI性能问题分析**

     - 应用UI卡顿原理
       尽量保证每次在16ms（60帧/秒、16ms/帧）内处理完所有的CPU与GPU计算、绘制、渲染等操作，否则会造成丢帧卡顿问题。

     - 应用卡顿常见原因

       1. 人为再UI线程中做轻微耗时操作，导致UI线程卡顿
       2. 布局Layout过于复杂，无法在16ms内完成渲染
       3. 同一时间动画执行的次数过多，导致CPU或GPU负载过重
       4. View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负责过重
       5. View频繁的触发`measure` `layout` 导致整个View频繁的重新渲染
       6. 内存频繁GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作
       7. 冗余资源及逻辑等导致加载和执行缓慢
       8. ANR

     - 应用UI卡顿分析解决方法

       1. 使用GPU过度绘制分析UI性能
          设置->开发者选项->调试GPU过度绘制

          |  颜色  |        含义         |
          | :----: | :-----------------: |
          |  无色  | WebView等的渲染区域 |
          |  蓝色  |     1x过度绘制      |
          |  绿色  |     2x过度绘制      |
          | 淡红色 |     3x过度绘制      |
          |  红色  |    4x(+)过度绘制    |

       2. 使用HierarchyViewer工具分析UI性能

       3. 使用GPU呈现模式图及FPS考核UI性能
          设置->开发者选项->GPU呈现模式

       4. 使用Lint进行资源及冗余UI布局等优化

       5. 使用Memory监测及GC打印与Allocation Tracker进行UI卡顿分析

       6. 使用Traceview和dmtracedump进行分析优化

       7. 使用Systrace进行分析优化

     - 应用UI性能分析解决总结

       1. 布局优化：
       2. 列表及Adapter优化
       3. 背景和图片等内存分配优化
       4. 自定义View等绘图与布局优化
       5. 避免ANR，不要再UI线程中做耗时操作，遵守ANR规避守则，譬如多次数据库操作等。

   - **应用内存性能分析优化**

     - 应用级内存管理原理
       App运行在自己的虚拟机中的内存管理基本就是遵循Java的内存管理机制，系统在特定的情况下主动进行垃圾回收。要注意的一点是在Android系统中执行垃圾回收（GC）操作时，所有线程（包含UI线程）都必须暂停，等垃圾回收操作完成之后其他线程才能继续运行。这些GC垃圾回收分别有：

       | 类型              | 含义                                             |
       | ----------------- | ------------------------------------------------ |
       | GC_MALLOC         | 内存分配失败时触发                               |
       | GC_CONCURRENT     | 当分配的对象大小超过一个限定值（不同系统）时触发 |
       | GC_EXPLICIT       | 对垃圾收集的显式调用(System.gc())                |
       | GC_EXTERNAL_ALLOC | 外部内存分配失败时触发                           |

     - 内存泄漏概念
       在Java中有些对象的生命周期是有限的，当它们完成了特定的逻辑后将会被垃圾回收；但是，如果在对象的生命周期本来该被垃圾回收时这个对象还被别的对象所持有引用，那就会导致内存泄漏；这样的后果就是随着我们的应用被长时间使用，他所占用的内存越来越大。

       内存泄露可以引发很多的问题，常见的内存泄露导致问题如下：

       - 应用卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）
       - 应用被从后台进程干为空进程（超过了阈值）
       - 应用莫名的崩溃（超过了阈值OOM）

       <u>造成内存泄漏的最核心的原理是一个对象持有了超过自己生命周期意外的对象强引用导致该对象无法被正常垃圾回收</u>。

     - 应用内存泄漏察觉手段

       | 察觉方式                  | 场景                                                         |
       | ------------------------- | ------------------------------------------------------------ |
       | AndroidStudio的Memory窗口 | 平时用来直观了解自己应用的全局内存情况，大的泄露才能有感知。 |
       | DDMS-Heap内存监测工具     | 同上，大的泄露才能有感知。                                   |
       | dumpsys meminfo命令       | 常用方式，可以很直观的察觉一些泄露，但不全面且常规足够用。   |
       | leakcanary神器            | 比较强大，可以感知泄露且定位泄露；实质是MAT原理，只是更加自动化了，当现有代码量已经庞大成型，且无法很快察觉掌控全局代码时极力推荐；或者是偶现泄露的情况下极力推荐。 |

     - 应用开发规避内存泄漏建议

       - 不要对`Activity Context`保持长生命周期的引用，尽量在一切可以使用`Application Context`代替。
       - 非静态内部类的静态实例容易造成内存泄漏；即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊`Handler`等），则尽量使用静态类和弱引用来处理（譬如`ViewRoot`的实现）。
       - 警惕新城为终止造成的内存泄漏；譬如在Activity中关联了一个生命周期超过Activity的Thread，在退出Activity时切记结束线程。一个典型的例子就是`HandlerThread`的`run()`方法是一个死循环，它不会自己结束，线程的生命周期超过了Activity生命周期，我们必须手动在Activity的销毁方法中中调运`thread.getLooper().quit()`。
       - 对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。
       - 创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。
       - 不要在执行频率很高的方法或者循环中创建对象，可以使用`HashTable`等创建一组对象容器从容器中取那些对象，而不用每次`new`与`release`。
       - 避免代码设计模式的错误造成内存泄露。

2. ANR 产生的原因是什么？怎么定位？
   - 主线程做了非常耗时的操作
   - 在BroadcastReceiver里做耗时的操作或计算 
   - CPU使用过高
   - 发生了死锁
     

3. 如何定位ANR？
  一般情况下，如果有ANR发生，系统都会记录在`/data/anr/traces.txt`文件；通过使用adb命令查看分析ANR产生原因（需要root）

  ```shell
  adb shell
  cd data/anr
  cat traces.txt
  ```

  

4. OOM 是否可以 try catch？
   为了避免应用在分配Bitmap内存的时候出现`OutOfMemory`异常以后Crash掉，通常在实例化Bitmap的代码中，要对`OutOfMemory`异常进行捕获。但是对于`OutOfMemoryError`来说，这样做是捕获不到的。因为`OutOfMemoryError`是一种`Error`，而不是`Exception`。

   ```java
   Bitmap bitmap = null;
   try {
       // 实例化Bitmap
       bitmap = BitmapFactory.decodeFile(path);
   } catch (OutOfMemoryError e) {
       
   }
   if (bitmap == null) {
       // 如果实例化失败 返回默认的Bitmap对象
       return defaultBitmapMap; 
   }
   ```

   

5. 解决OOM的方法有哪些？

   - 动态回收内存
   - 为应用分配更多的内存
   - 自定义内存大小
   - 内部类使用`static`
     

6. 造成内存泄漏的原因？如何解决？

   - 新建线程引起的Activity内存泄漏

     ```java
     /**
      * 错误示范
      * 当Activity执行finish()后，发生了内存泄漏
      * 因为匿名内部类会持有外部类的引用，当外部类销毁，内部类的线程还在执行，
      * 导致外部类所占用的内存不能被GC回收，将匿名内部类改成静态非匿名内部类即可。
      */
     new Thread(new Runnable() {
         @Override
         public void run() {
             try {
                 // 模拟耗时操作
                 Thrad.sleep(15000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         }
     }).start();
     
     
     
     // 解决方法
     private static class MyRunnable implements Runnable {
         @Override
         public void run() {
             try {
                 // 模拟耗时操作
                 Thrad.sleep(15000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         }
     }
     
     new Thread(new MyRunnable());
     ```

   - Activity添加监听器造成的内存泄漏

     ```java
     /**
      * 错误示范
      * Manager的静态实例持有Activity的实例，当Activity销毁后导致所占用的内存不能被GC回收，从而造成内存泄漏
      */
     Manager.getInstance().addListener(this);
     
     //解决方法
     @Override
     protected void onDestory() {
         super.onDestory();
         //当Activity销毁时，取消Manager的监听绑定
         Manager.getInstance().removeListener(this);
     }
     ```

   - Handler一名内部类造成的内存溢出

     ```java
     //错误示范
     private Handler handler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
             super.handleMessage(msg);
             //TODO
         }
     }
     
     new Thread(new Runnable() {
         @Override
         public void run() {
             handler.sendEmptyMessage(MSG_CODE);
             try {
                 // 模拟耗时操作
                 Thrad.sleep(8000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             handler.sendEmptyMessage(MSG_CODE);
         }
     }).start();
     
     //解决方法
     private static class MyHandler extends Handler {
         WeakReference<MyActivity> weakReference;
         
         public MyHandler(MyActivity activity) {
             weakReference = new WeakReference<MyActivity>(activity);
         }
         
         @Override
         public void handleMessage(Message msg) {
             super.handleMessage(msg);
             if (weakReference.get() != null) {
                 //TODO
             }
         }
     }
     
     private static class MyRunnable implements Runnable {
         @Override
         public void run() {
             handler.sendEmptyMessage(MSG_CODE);
             try {
                 // 模拟耗时操作
                 Thrad.sleep(15000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
             handler.sendEmptyMessage(MSG_CODE);
         }
     }
     
     handler = new MyHandler(this);
     new Thread(new MyRunnable());
     
     @Override
     protected void onDestory() {
         super.onDestory();
         //当Activity销毁时，将所有的Callbacks和Messages全部清除
         handler.remoevCallbacksAndMessage(null);
     }
     ```

   - AsyncTask造成的内存泄漏
     通过自定义静态AsyncTask类可解决

   - 单例模式引发的内存泄漏
     尽量使用`MyApplication.getAppInstance().getApplicationContext()`实例初始化，若用Activity的实例，记得在Activity销毁的时候释放引用。

   - 资源对象没有关闭引发的内存泄漏
     比如：Cursor,File,Bitmap,Video等，系统都运用了缓存技术，如不再使用这些资源时，不及时回收可以引发内存泄漏，所以记得调用类似的方法：`close()` 、`recycler()` 、`release()`。

   - 集合对象没有及时清理引发的内存泄漏
     如果集合是`static`的，不断往里添加东西，而又不及时清理时，可能会引起内存泄漏。

7. ddms 和 traceView 的使用？

8. 性能优化如何分析 systrace？

9. 用 IDE 如何分析内存泄漏？

10. Java 多线程引发的性能问题，怎么解决？

11. 启动页白屏、黑屏、太慢怎么解决？

12. App 启动崩溃异常怎么捕捉？ 对于 Android App 闪退，可能有哪些原因？请针对每种情况简述分析过程。【猎豹移动】

13. 如何保持应用的稳定性？

14. RecyclerView 和 ListView 的性能对比？

15. RecyclerView如何实现点击事件？

16. Bitmap 如何处理大图？如何预防 OOM？

17. 如何缩小 Apk 的体积？

18. 如何统计启动时长？

### Gradle

1. Gradle 源码解析
2. 对热修复和插件化的理解？
3. 插件化原理分析
4. 模块化实现（好处，原因）
5. 项目组件化的理解
6. 描述清点击 Android Studio 的 build 按钮后发生了什么？

### Kotlin

1. 谈谈对 Kotlin 的理解
2. 闭包和局部内部类的区别？

## 网络基础

1. 描述一次网络请求的流程？
   - 域名解析
   - TCP 3次握手
   - 建立连接后发起Http请求
   - 服务器响应请求
   - 浏览器解析Html代码，同时请求资源
   - 浏览器渲染
   - TCP 4次挥手 
   
2. TCP 中 3次握手和 4次挥手的过程？
3. TCP 与 UDP 的区别及应用？
4. HTTP 协议
5. HTTP 1.0 与 2.0 的区别
6. HTTP 报文结构
7. HTTP 与 HTTPS 的区别以及如何实现安全性
8. HTTPS 原理
9. 谈谈你对 WebSocket 的理解
10. WebSocket 与 socket 的区别
11. 视频加密传输

## 数据结构与算法

### 数据结构

- 简述常见的数据结构？
- 堆的结构？
- 树、B+ 树、二叉树、红黑树的了解？
- 二叉树的深度优先遍历和广度优先遍历？
- 堆和树的区别？
- 图的了解？

### 算法

- 排序算法有哪些？

- 最快的排序算法是哪个？

- 手写冒泡排序

- 手写快速排序

- 快速排序的过程、时间复杂度、空间复杂度

- 手写堆排序

- 单例模式

  - 饿汉模式：

    ```java
    //只有内部类可以为static。
    public class SingIn {
        //在自己内部定义自己的一个实例，只供内部调用
        private static final SingIn instance = new SingIn();
        
        private SingIn() {
        }
        
        //这里提供了一个供外部访问本class的静态方法，可以直接访问
        public static SingIn getInstance(){
            return instance;
        }
    }
    ```

  - 懒汉模式：

    ```java
    //一种常用的形式
    private static SingIn instance = null; 
    public static synchronized SingIn getInstance() {         
        // 这个方法比上面有所改进，不用每次都进行生成对象，只是第一次  
        // 使用时生成实例，提高了效率！  
        if (instance == null)  
            instance = new SingIn();  
        return instance;  
    }
    ```

  - 双重锁定：

    ```java
    //将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。 
    private static volatile SingIn instance = null;
    private SingIn() {
        
    }
     public static SingIn getInstance() {
        if(instance == null) {
            synchronized(SingIn.class) {
                if(instance == null) {
                    instance = new SingIn ();
                }
            }
        }
         
        return instance;
      }
    ```

    

### 常见算法问题

- 给阿里2万多名员工按年龄排序应该选择哪个算法？
- GC算法(各种算法的优缺点以及应用场景)
- 子串包含问题(KMP 算法)写代码实现
- 一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法
- 万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)
- 两个不重复的数组集合中，求共同的元素。
- 两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？
- 一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法
- 一张Bitmap所占内存以及内存占用的计算
- 2000万个整数，找出第五十大的数字？
- 求1000以内的水仙花数以及40亿以内的水仙花数
- 烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？
- 5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同
- 时针走一圈，时针分针重合几次
- 请对比2月份和3月份的在职员工文件（txt）,输出3月份离职的员工？



## 设计模式与架构

### 设计模式

1. 项目中常用的设计原则有哪些？
   - 单一职责原则
     建议接口一定要做到单一职责，类的设计尽量做到只有一个原因引起的变化
   - 开放封闭原则
     这个原则有两个特性，一个是说“对于扩展是开放的”，另一个是说“对于更改是封闭的”。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这就是“开放-封闭原则”的精神所在。
   - 里氏替换原则
     只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。
   - 依赖倒置原则
     高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；依赖倒置原则就是要我们面向接口编程。
   - 接口分离原则
     建立功能单一细化的接口，接口中的方法尽量少，避免接口庞大臃肿。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
2. 谈谈你对 Android 设计模式的理解
   - Builder模式
   - 迭代器模式
   - 模板方法模式
   - 访问者模式
   - 中介者模式
   - 代理模式（委托模式）
   - 组合模式
   - 适配器模式
   - 装饰模式
   - 享元模式
   - 外观模式
3. 项目中常用的设计模式有哪些？
   - 单例模式
   - 观察者模式
   - 原型模式
   - 策略模式
4. 手写生产者-消费者模式？
5. 手写观察者模式？
6. 适配器模式、装饰者模式、外观模式的异同？

### 架构

- MVC、MVP、MVVM 原理和区别？
  - MVC
    ![MVC](..\images\android\MVC.png)
  - MVP
    ![MVP](..\images\android\MVP.png)
  - MVVM
    ![MVVM](..\images\android\MVVM.png)
- 对 RxJava 的理解，功能与原理，优缺点？
- 从 0 设计一款 App 整体架构，如何去做？
- Fragment 如果在 Adapter 中使用应该如何解耦？
- 对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？
- 实现一个 Json 解析器（可以通过正则提高速度）？
- 说说你看过的Android源码？

## 其他方面
### 项目分析
- OkHttp
  ![网络框架对比](..\images\android\网络框架对比.png)
- Retrofit
  ![Retrofit流程图](..\images\android\Retrofit流程图.png)
- OkSocket
- ijkplayer

### 人事相关

- 请简单做个自我介绍？
- 为什么离开上家公司？您在前一家公司的离职原因是什么？
- 讲一个你认为做的最好的项目/案例
- 你上家公司的薪水/期望的薪金？
- 你对薪资的要求？
- 对待加班看法？
- 自己最擅长的技术点，最感兴趣的技术领域和技术点，做了那些东西？
- 自己的优点和缺点是什么？并举例说明？
- 你朋友对你的评价？
- 说下项目中遇到的棘手问题，包括技术，交际和沟通？
- 项目中遇到最大的困难是什么？如何解决的？
- 在五年的时间内，你的职业规划？
- 给你一个项目，你怎么看待他的市场和技术的关系？
- 你的学习方法是什么样的？实习过程中如何学习？实习项目中遇到的最大困难是什么以及如何解决的？
- 工作上与领导意见不同时，怎么办？
- 若上司在公开会议上误会你了，该如何解决？
- 你和别人发生过争执吗？你是怎样解决的？
- 你为什么愿意到我们公司来工作？
- 你最擅长的技术点，最感兴趣的技术领域和技术点？
- 说说你对行业、技术发展趋势的看法？
- 就你申请的这个职位，你认为你还欠缺什么？
- 如果你在这次面试中没有被录用，你怎么打算？
- 你还要什么了解和要问的吗？
- 评价下自己，评价下自己的技术水平，个人代码量如何？
- 介绍你做过的哪些项目，介绍一个你影响最深的项目？
- 都使用过哪些自定义控件？
- 项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题？
- 有没有什么开源项目？
- 研究比较深入的领域有哪些？
- 业余都有哪些爱好？
- 你的梦想是什么？