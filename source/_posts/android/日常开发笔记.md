---
title: 日常开发笔记
date: 2018-01-23 21:30:50
updated: 2018-01-23 21:30:50
tags: [android, note]
categories: android
---


# 日常开发笔记


### Space 使用场景
Space 是一个用于创建视图之间空隙的轻量级View，再onDraw()中不执行任何绘制，所以`android:background` 属性对它不起作用。

通常在创建视图空隙的时候，**在不考虑背景色的情况下，Space效率更高**。

> 注意：由于控件是 API 14 引入，如要向下兼容，需要使用**v4.widget.Space**



### 自动调用View点击事件，模拟用户点击行为

```java
view.performClick();
view.performLongClick();
```



### 系统内置方法/工具

#### DateUtils
`DateUtils.formayDateTime()`代替JDK中的`new SimpleDateFormat("yyy-MM-dd HH:mm").format()`。
几个常用的format格式：
- FORMAT_SHOW_DATE：3月3日
- FORMAT_SHOW_TIME：10:37
- FORMAT_SHOW_WEEKDAY：星期五
- FORMAT_SHOW_YEAR：2017年3月3日
- FORMAT_NUMERIC_DATE：3/3
- FORMAT_NO_MONTH_DAY：三月



#### TextUtils

`TextUtils.isEmpty(CharSequence str)`



#### Log

`Log.getStackTraceString(Throwable tr)`可以从Throwable对象中获取错误信息，并以字符串形式返回。当你需要错误信息的数据持久化时，这个方法很方便。
使用场景：保存至本地存储卡或上传服务器。



### 5个常见的内存泄露的问题

内存泄露时造成OOM的主要原因之一。由于Android系统为每个应用程序分配的内存有限，当一个应用中产生内存泄露较多时，就南偏灰导致应用所需要的内存超过分配的限额，这就导致应用Crash。



#### 1. 单例造成的内存泄露

由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，也就说明如果一个对象已经不需要使用的时候，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄露。
举例：
```java
//worng
public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context;
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
//right
public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context.getApplicationContext();
    }
    public static AppManager getInstance(Context context) {
        if (instance != null) {
            instance = new AppManager(context);
        }
        return instance;
    }
}
```
#### 2. 非静态内部类创建静态实例造成的内存泄露


#### 2.1 Handler造成的内存泄露
Handler正确的使用方式：
```java
private MyHandler mHandler = new MyHandler(this);
private static class MyHandler extends Handler {
        private WeakReference<Context> reference;
        public MyHandler(Context context) {
            reference = new WeakReference<>(context);
        }
        @Override
        public void handleMessage(Message msg) {
            Activity activity = (Activity) reference.get();
            if(activity != null){
                //do something
                //...
            }
        }
    }
    
    @Override
    protected void onDestroy() {
      super.onDestroy();
      mHandler.removeCallbackAndMessage(null);
    }
```
#### 3. 非静态内部类

#### 3.1 线程造成的内存泄露
```java
//test1
new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                SystemClock.sleep(10000);
                return null;
            }
        }.execute();
        
//test2
new Thread(new Runnable() {
            @Override
            public void run() {
                SystemClock.sleep(10000);
            }
        }).start();
```
上面的一部任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐士引用。
如果Activity在销毁之前，任务还没完成，那么导致Activity的内存资源无法回收，造成内存泄露。
正确的做法，应该使用静态内部类的方式实现，如下：
```java
static class MyAsyncTask extends AsyncTask<Void, Void, Void> {
        private WeakReference<Context> weakReference;
  
        public MyAsyncTask(Context context) {
            weakReference = new WeakReference<>(context);
        }
  
        @Override
        protected Void doInBackground(Void... params) {
            SystemClock.sleep(10000);
            return null;
        }
  
        @Override
        protected void onPostExecute(Void aVoid) {
            super.onPostExecute(aVoid);
            MainActivity activity = (MainActivity) weakReference.get();
            if (activity != null) {
                //...
            }
        }
    }
    static class MyRunnable implements Runnable{
        @Override
        public void run() {
            SystemClock.sleep(10000);
        }
    }
    
    //-------
    new Thread(new MyRunnable()).start();
    new MyAsyncTask(this).execute();
```
这样就避免了Activity的内存资源泄露，当然在Activity销毁时也应该取消相应的任务`AsyncTask.cancel()`，避免任务在后台执行浪费的资源。

#### 4. 资源未关闭造成的内存泄露
对于BroadcastReceiver、File、Stream、 Cursor、Bitmap 等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄露。

### 资源相关

#### string.xml 
`<b></b>` 加粗字体
`<i></i>` 斜体字体
`<u></u> `给字体加下划线
`\n` 换行
`\u0020` 表示空格
`\u2026` 表示省略号


####SpannableString 与 SpannableStringBuilder
类似于String和StringBuilder
SpannableString 长度不可变
SpannableStringBuilder 长度可变

#### `@`和`?`之间的区别
@ 标记是引用一个实际的值（color, string, dimension...）。
? 标记是引用一个`style attribute`，其值取决于当前使用的主题。

#### InputFilter
`EditText.maxLength` 在使用InputFilter 之后会失效

#### 什么是线程安全？
线程安全是指多线程访问统一代码，不会产生不确定的结果。

#### view.post
view获取到关联线程（即UI线程，因为只有UI线程才能创建view）的handler，然后调用该handler的post方法，即把这个任务封装成一个消息post到主线程的消息队列中，然后等待执行。

#### 代码混淆
1. 开启代码混淆
```
buildTypes {
  release {
    minifyEnabled false
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-reles.pro'
  }
}
```

2. 添加混淆规则
```
-dontskipnonpubliclibraryclasses # 不忽略非公共的库类
-optimizationpasses 5 # 指定代码的压缩级别
-dontusemixedcaseclassnames # 是否使用大小写混合
-dontpreverify # 混淆时是否做预校验
-verbose # 混淆时是否记录日志
-keepattributes *Annotation* # 保持注解
-ignorewarning # 忽略警告
-dontoptimize # 优化不优化输入的类文件

-optimizations !code/simplification/arithmetic,!field/*,!class/merging/* # 混淆时所采用的算法

#保持哪些类不被混淆
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class com.android.vending.licensing.ILicensingService

#生成日志数据，gradle build时在本项目根目录输出
-dump class_files.txt #apk包内所有class的内部结构
-printseeds seeds.txt #未混淆的类和成员
-printusage unused.txt #打印未被使用的代码
-printmapping mapping.txt #混淆前后的映射

-keep public class * extends android.support.** #如果有引用v4或者v7包，需添加
-libraryjars libs/xxx.jar #混淆第三方jar包，其中xxx为jar包名
-keep class com.xxx.**{*;} #不混淆某个包内的所有文件
-dontwarn com.xxx** #忽略某个包的警告
-keepattributes Signature #不混淆泛型
-keepnames class * implements java.io.Serializable #不混淆Serializable

-keepclassmembers class **.R$* { #不混淆资源类
public static <fields>;
}
-keepclasseswithmembernames class * { # 保持 native 方法不被混淆
native <methods>;
}
-keepclasseswithmembers class * { # 保持自定义控件类不被混淆
public <init>(android.content.Context, android.util.AttributeSet);
}
-keepclasseswithmembers class * { # 保持自定义控件类不被混淆
public <init>(android.content.Context, android.util.AttributeSet, int);
}
-keepclassmembers class * extends android.app.Activity { # 保持自定义控件类不被混淆
public void *(android.view.View);
}
-keepclassmembers enum * { # 保持枚举 enum 类不被混淆
public static **[] values();
public static ** valueOf(java.lang.String);
}
-keep class * implements android.os.Parcelable { # 保持 Parcelable 不被混淆
public static final android.os.Parcelable$Creator *;
}
```

### PopupWindow 和 Dialog的区别
**不同点**
2. Popupwindow在显示之前一定要设置宽高，Dialog无此限制。
3. Popupwindow默认不会响应物理键盘的back，除非显示设置了popup.setFocusable(true)；而在点击back的时候，Dialog会消失。
4. Popupwindow不会给页面其他的部分添加蒙层，而Dialog会。
5. Popupwindow没有标题，Dialog默认有标题，可以通过`dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);`取消标题

AlertDialog是**非阻塞式**对话框，AlertDialog弹出时，后台还可以做其他事情；而PopupWindow是**阻塞式**对话框，PopupWindow弹出直至PopupWindow推出前，程序会一直等待，等待dismiss方式执行后，程序才会想下执行。
这两种区别的表现是：

**共同点**
1. 二者显示的时候都要设置Gravity，如不设置，Dialog默认是Gravity.CENTER
2. 二者都有默认的背景，都可以通过`setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));`去掉。

### 深入理解 fitsSystemWindows
透明状态栏是 Android apps 中经常需要实现的一种效果，很长一段时间，开发者都要为不同版本的适配而头痛，自 Android 4.4 KitKat 以来，系统中就已经提供修改状态栏（SystemUI）显示行为的选项了。其中带来的一个最令人困惑的问题就是 `fitsSystemWindows` 这个属性究竟该如何使用。

我们知道，给 Activity 设置透明状态栏十分简单，使用下面的 code snippet 就可以了：
```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
    Window window = getWindow();
    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    window.setStatusBarColor(Color.TRANSPARENT);
}
```
它相较于直接在 style.xml 中定义样式的好处就是不会有一个 scrim（不知道怎么翻译好，就是那个半透明的遮罩）。但只做这个工作就会导致下面这个情况：
<br>
<br>
![Figure 1.](/res/android/1.png)
<br>
<br>
内容与状态栏区域重叠了！通常，大多数人会在布局中加一个：
```xml
android:fitsSystemWindows="true"
```
然后状态栏就显示正常了，但这还取决于布局，有的布局类直接加这个属性可能就不 work，尤其是 `CoordinatorLayout` 相关的布局，让人感觉这个属性很迷。确实，没有分析源码的时候我也很困惑。但经过简单的分析，一切都不是秘密。

#### 初步分析

首先要想搞清楚这个属性的作用，我们就要到类中看看设置相关属性后到底会发生什么变化，于是找到 View 类的 `setFitsSystemWindows` 方法：
```java
public void setFitsSystemWindows(boolean fitSystemWindows) {
    setFlags(fitSystemWindows ? FITS_SYSTEM_WINDOWS : 0, FITS_SYSTEM_WINDOWS);
}
```
额，好吧，其实经过继续跟踪之后，改变这个 flag 根本不会造成 View 的重新布局和 invalidate，所以这个属性一定是要在布局发生之前设置好的。但是看方法文档可以发现，这个属性与一个名为 `fitSystemWindows` 的方法密切相关，看一下：
```java
protected boolean fitSystemWindows(Rect insets) {
    if ((mPrivateFlags3 & PFLAG3_APPLYING_INSETS) == 0) {
        if (insets == null) {
            // Null insets by definition have already been consumed.
            // This call cannot apply insets since there are none to apply,
            // so return false.
            return false;
        }
        // If we're not in the process of dispatching the newer apply insets call,
        // that means we're not in the compatibility path. Dispatch into the newer
        // apply insets path and take things from there.
        try {
            mPrivateFlags3 |= PFLAG3_FITTING_SYSTEM_WINDOWS;
            return dispatchApplyWindowInsets(new WindowInsets(insets)).isConsumed();
        } finally {
            mPrivateFlags3 &= ~PFLAG3_FITTING_SYSTEM_WINDOWS;
        }
    } else {
        // We're being called from the newer apply insets path.
        // Perform the standard fallback behavior.
        return fitSystemWindowsInt(insets);
    }
}
```
这里面涉及一个转发修正的问题，我们这里先不去管它，直接看真正的实现`fitSystemWindowsInt`：
```java
private boolean fitSystemWindowsInt(Rect insets) {
    if ((mViewFlags & FITS_SYSTEM_WINDOWS) == FITS_SYSTEM_WINDOWS) {
        mUserPaddingStart = UNDEFINED_PADDING;
        mUserPaddingEnd = UNDEFINED_PADDING;
        Rect localInsets = sThreadLocal.get();
        if (localInsets == null) {
            localInsets = new Rect();
            sThreadLocal.set(localInsets);
        }
        boolean res = computeFitSystemWindows(insets, localInsets);
        mUserPaddingLeftInitial = localInsets.left;
        mUserPaddingRightInitial = localInsets.right;
        internalSetPadding(localInsets.left, localInsets.top,
                localInsets.right, localInsets.bottom);
        return res;
    }
    return false;
}
```
可以看到，`fitsSystemWindows` 这个属性在这发挥了用武之地，如果设置了这个属性，那么就会有一个 padding 的设置，那这个 padding 来自哪，它是什么，现在还不得而知，这里就预计是状态栏的区域吧。padding 有什么用呢，ViewGroup 的一些子类在 measure 和 layout 的时候会获取 super 中与 padding 相关的成员变量来做布局上的调整，这就可以实现避开状态栏的问题了。

但是，上述方法的调用时机究竟是什么时候呢，我们可以通过 IDE 中强大的 **Find Usages** 来反向推导一下。最后发现它是由一个名为 `dispatchApplyWindowInsets` 的方法调用的，而且通过参数传了一个 `WindowInsets` 对象，这是什么鬼，我们后面就会讲到。在此之前我们断点打一下，看看这个方法是怎么被调用起来的：
<br>
<br>
![Figure 2.](res/android/2.png)
<br>
<br>
原来是 `ViewRootImpl` 发起的，这个类很重要，实现了很多 View 与 **WindowManager** 的交互，这里 `ViewRootImpl` somehow 拿到了一个 `WindowInsets` 对象，这个对象大家可以看看文档，就是包含了一些系统所占用的区域，**这些区域可以被消耗掉，并且消耗之后返回的是一个全新的对象，这句话请谨记**。

有关状态栏的高度包含在这个对象中无疑了，为了日后的扩展性，这个对象可能还会新增更多的 insets 类型，但就目前而言，仅限于状态栏和圆形手表上的一些特殊模式。

好，我们继续分析上面提到的那个方法：
```java
public WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {
    try {
        mPrivateFlags3 |= PFLAG3_APPLYING_INSETS;
        if (mListenerInfo != null && mListenerInfo.mOnApplyWindowInsetsListener != null) {
            return mListenerInfo.mOnApplyWindowInsetsListener.onApplyWindowInsets(this, insets);
        } else {
            return onApplyWindowInsets(insets);
        }
    } finally {
        mPrivateFlags3 &= ~PFLAG3_APPLYING_INSETS;
    }
}
```
可以看到，这里不管设没设置 `fitsSystemWindows` 属性，都会激发一个 `onApplyWindowInsets` 回调，并且这个回调还可以通过 Listener 设置，有点意思。当然了，默认的回调实现的功能上面已经分析过了。

到现在为止貌似就可以解释为什么设置 `fitsSystemWindows` 属性后，绝大部分布局就可以避开状态栏了。但是不知道你有没有发现 `CoordinatorLayout` 会在状态栏下面画一个底色？`FrameLayout` 就没有这个特技，看来 `CoordinatorLayout` 的处理方式并非一个简单的 padding，肯定有自己的实现逻辑。

我们去它的源码找找看：
```java
@Override
    public void setFitsSystemWindows(boolean fitSystemWindows) {
    super.setFitsSystemWindows(fitSystemWindows);
    setupForInsets();
}
```
直奔 `setupForInsets`：
```java
private void setupForInsets() {
    if (Build.VERSION.SDK_INT < 21) {
        return;
    }

    if (ViewCompat.getFitsSystemWindows(this)) {
        if (mApplyWindowInsetsListener == null) {
            mApplyWindowInsetsListener =
                    new android.support.v4.view.OnApplyWindowInsetsListener() {
                        @Override
                        public WindowInsetsCompat onApplyWindowInsets(View v,
                                WindowInsetsCompat insets) {
                            return setWindowInsets(insets);
                        }
                    };
        }
        // First apply the insets listener
        ViewCompat.setOnApplyWindowInsetsListener(this, mApplyWindowInsetsListener);

        // Now set the sys ui flags to enable us to lay out in the window insets
        setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE
                | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);
    } else {
        ViewCompat.setOnApplyWindowInsetsListener(this, null);
    }
}
```
这段代码可以说就是 View 需要自定义 `fitsSystemWindows` 行为的标准范式。核心的处理逻辑就在 `setWindowInsets` 这个方法中：
```java
final WindowInsetsCompat setWindowInsets(WindowInsetsCompat insets) {
    if (!objectEquals(mLastInsets, insets)) {
        mLastInsets = insets;
        mDrawStatusBarBackground = insets != null && insets.getSystemWindowInsetTop() > 0;
        setWillNotDraw(!mDrawStatusBarBackground && getBackground() == null);

        // Now dispatch to the Behaviors
        insets = dispatchApplyWindowInsetsToBehaviors(insets);
        requestLayout();
    }
    return insets;
}
```
知道状态栏下面的背景怎么来的了吧。

到这里理顺一下思路：
`fitsSystemWindows` 与 `onApplyWindowInsets` 关系十分密切，后者将系统给出的 `WindowInsets` 派发给 View 让其根据前者这个属性来做自己的布局和绘制逻辑。

#### 进阶应用

这一部分我们来讨论一下 `WindowInsets` 这个类，它有一个很重要的概念：consume。

这个概念重要到什么程度呢？如果你搞不懂 consume 和其 immutability，你自己的布局或者自定义 View 基本就爆炸了。

当一个 `View` 的 `dispatchApplyWindowInsets` 被调用时，它需要对 `WindowInsets` 对象作出响应，然后将处理的结果返回，处理结果基本就两种：
1. 你消耗了这个 insets，这时其它 View 收到的 insets 就是 0。
2. 你不想消耗 insets，那么其它 View 将继续响应一开始的 insets 值。

还有一种特殊的情况：你返回了消耗过的 insets，但保存了一份原始 insets 引用，这时这个视图的**兄弟视图和其兄弟视图的子视图**就会收到值为 0 的 insets，而这个视图可以根据情况让它的子视图收到一个原始未消耗的 insets，这也是 `DrawerLayout` 所做的事情，想搞清它这么做的原因，本文就讲不完了，我后期可能会再开一篇文章分析。

讲这么多有没有 🌰 呢？当然有，先看下面的效果：
<br>
<br>
![Figure 3.](res/android/3.png)
<br>
<br>
显然，这是 `CoordinatorLayout` 配合 `CollapsingToolbarLayout` 实现的，但是这里给 `CoordinatorLayout` 加 `fitsSystemWindows` 就不灵了，它会吃掉状态栏的位置，然后画个背景色，我们的图片就不能垫在状态栏底下了，我通过分析各个类（这块真是花了很多时间），发现 `AppBarLayout` 也实现了 `fitsSystemWindows` 的自定义行为（毕竟放在它里面的 `CollapsingToolbarLayout` 有一个 `statusBarScrim` 属性），但是给它加上这个属性以后，图片依然会被挤下去。

怎么办呢？就在我扫荡 `CollapsingToolbarLayout` 的源码的时候发现了下面这段逻辑：
```java
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);

    if (mLastInsets != null) {
        // Shift down any views which are not set to fit system windows
        final int insetTop = mLastInsets.getSystemWindowInsetTop();
        for (int i = 0, z = getChildCount(); i < z; i++) {
            final View child = getChildAt(i);
            if (!ViewCompat.getFitsSystemWindows(child)) {
                if (child.getTop() < insetTop) {
                    // If the child isn't set to fit system windows but is drawing within
                    // the inset offset it down
                    ViewCompat.offsetTopAndBottom(child, insetTop);
                }
            }
        }
    }

    ...
}
```
这就是说，如果 `CollapsingToolbarLayout` 的某个子视图开启了 `fitsSystemWindows` 这个属性，那么它就会被填满父视图，否则，它就会被下移 top inset 的距离。那这个问题的解决方法就很明显了，直接给 `ImageView` 加一个 `fitsSystemWindows`，完事了。

不得不感叹 Android 设计的精巧。

在我这么做之前，我看了市面上 99% 的 app 都是用了很“暴力”的方式解决，强行算状态栏高度，然后设置 margin，很不优雅，实际上 Android 已经为我们考虑地十分周全了，很多效果基本都可以用原生的方式实现，就看你会不会做了，如何发现这些小技巧，还是要靠源码分析。

那么最后给大家留一个小小的 homework，可否给我们的图片在状态栏的位置加一个 scrim？（hint：可以参考 `NavigationView`）



#### 类的加载过程
   ![classload](E:\Blog\res\classload.jpg)

-    加载 loading
     加载阶段主要完成[三件](http://www.chinabyte.com/keyword/%E4%B8%89%E4%BB%B6/)事，即通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态[存储](http://storage.chinabyte.com/)结构转化为方法区的运行时数据结构，在Java堆中生成一个代表此类的Class对象，作为访问方法区这些数据的入口。这个加载过程主要就是靠类加载器实现的，这个过程可以由用户自定义类的加载过程。

-    验证 verification
            这个阶段目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种验证：

-    文件格式验证：基于字节流验证，验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机
     - 元数据验证：基于方法区的存储结构验证，对字节码描述信息进行语义
     - 字节码验证：基于方法区的存储结构验证，进行数据流和控制流的
     - 符号引用验证：基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用。

-    准备 preparation
            仅仅为类变量(即static修饰的字段变量)分配内存并且设置该类变量的初始值即零值，这里不包含用final修饰的static，因为final在编译的时候就会分配了，同时这里也不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

-    解析 resolution
            解析主要就是将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，[接口方法](http://www.chinabyte.com/keyword/%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95/)解析。

            　　这里要注意如果有一个同名字段同时出现在一个类的接口和父类中，那么编译器一般都会拒绝编译。

-    初始化 initialization
            初始化阶段依旧是初始化类变量和其他资源，这里将执行用户的static字段和静态语句块的赋值操作。这个过程就是执行类构造器方法的过程。

            　　方法是由编译器收集类中所有类变量的赋值动作和静态语句块的语句生成的，类构造器方法与实例构造器方法不同，这里面不用显示的调用父类的方法，父类的方法会自动先执行于子类的方法。即父类定义的静态语句块和静态字段都要优先子类的变量赋值操作。


### android事件分发机制

![viewgroup_touch](E:\Blog\res\viewgroup_touch.png)

| Touch 事件相关方法                             | 方法功能 | ViewGroup | Activity |
| :--------------------------------------- | ---- | --------- | -------- |
| public boolean dispatchTouchEvent(MotionEvent ev) | 事件分发 | Yes       | Yes      |
| public boolean onInterceptTouchEvent(MotionEvent ev) | 事件拦截 | Yes       | No       |
| public boolean onTouchEvent(MotionEvent ev) | 事件响应 | Yes       | Yes      |

#### onTouch和onTouchEvent有什么区别，又该如何使用？

这两个方法都是在View的dispatchTouchEvent中调用的，onTouch优先于onTouchEvent执行。如果在onTouch方法中通过返回ture将事件消费掉，onTouchEvent将不再执行。

- android事件分发是先传递到ViewGroup，再由ViewGroup传递到View。
- ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouch方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。
- 子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。

#### Touch事件的传递机制
- 所有Touch事件都被封装成MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指（多点触控）等。
- 事件类型分为：
  - ACTION_DOWN
  - ACTION_UP
  - ACTION_MOVE
  - ACTION_POINTER_DOWN
  - ACTION_POINTER_UP
  - ACTION_POINTER_CANCEL
- 每个事件都是以ACTION_DOWN开始，以ACTION_UP结束。

1. 事件从Activity的dispatchTouchEvent开始传递，只要onInterceptTouchEvent不进行拦截，从最上层的View(ViewGroup)开始一直往下（子View）传递。子View可以通过onTouchEvent对事件进行处理。
2. 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent。
3. 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。
4. OnTouchListener优先于onTouchEvent执行。

#### Activity Window View 三者的差别
Activity 控制单元，Window 承载模型，View 显示视图

Activity在onCreate中调用attach方法，在attach方法中创建一个window对象。window对象创建时并没有创建DocerView对象，而是当用户在Activity中调用setContentView方法之后，接着转到window的setContentView，这时会检查DecorView是否存在，如果不存在则创建DecorView对象，然后把用户自己的View添加到DecorView中。

#### LayoutInflater
LayoutInflater只做一件事，就是把xml表述的layout转化为View。

#### LaunchMode 应用场景
- standard：创建一个新的Activity
- singleTop：栈顶不是该类型的Activity，创建一个行的Activity。否则，onNewIntent。
- singleTask：回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent + ClearTop。
- singleInstance：回退栈中只有这个Activity，没有其他Activity。


#### ListView优化
- 复用convertView，使用ViewHolder
- item中有图片时，异步加载，适当对图片进行压缩
- 监听滚动事件，滑动时不加载图片
- 实现上拉加载更多，进行分页加载

#### 自定义View的基本流程
1. 覆写onDraw、onMeasure、onLayout
2. 覆写dispatchTouchEvent、onTouchEvent
3. 覆写自定义属性，编写attr.xml，然后在代码中通过TypedArray等类获取自定义属性值
4. 处理滑动冲突、像素转换等问题
   Other
5. 编写attr.xml文件
6. 在layout布局文件中引用，同时引用命名空间
7. 在自定义控件中进行读取（构造方法拿到attr.xml文件值）
8. 覆写onMeasure
9. 覆写onLayout





# Daily knowledge

1. 什么是类？什么是对象？类和对象之间的关系？

   > 类是对象的集合，是抽象的；对象是类的实例化，是具体的。

2. 简述C/C++的核心思想

   > http://www.cnblogs.com/lanxuezaipiao/p/4135105.html

3. 泛型的本质

   > 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为某个参数类型。
   >
   > 这种参数类型可以在类、接口和方法中创建，分别称为泛型类、泛型接口、泛型方法。
   >
   > 优点：在编译的时候检查类型安全，并且素有的强制转换都是自动和隐式的，提高代码的重用率。
   >
   > 缺点：

4. 静态变量的使用场景

   > 1. 变量所包含的对象提及较大，占用内存较多。
   > 2. 变量所包含的对象生名周期较长。
   > 3. 变量所包含的对象数据稳定。
   > 4. 该类的对象实例有对该变量所包含的对象共享需求。

5. 类加载原理及类加载器

6. 对Clone的理解

7. HashMap的实现

8. Collection和Collections的区别

9. 数组浅析

10. 代码优化编程

11. 事件处理机制与"恋爱关系"

12. JNDI(Java命名与目录接口)

13. Comparable和Comparator实现对象比较

14. String、StringBuffer与StringBuilder之间的区别

   > String：字符串常量
   >
   > StringBuffer：字符串变量，线程安全
   >
   > StringBuilder：字符串变量，线程非安全
   >
   > 三者在执行速度方面的比较：StringBuilder > StringBuffer > String
   >
   > **总结**：
   >
   > 1. 操作少量的数据用 String
   > 2. 单线程操作字符串缓冲区下操作大量数据 StringBuilder
   > 3. 多线程操作字符串缓冲区下操作大量数据 StringBuffer

15. Heap和Stack的区别

16. 反射机制



1.  Synchronized的使用

    > synchronized代码块：
    >
    > synchronized方法：
    >
    > synchronized静态方法：
    >
    > synchronized类：
    >
    > synchronized()：
2.  android:background="?/attr/..."
3.  DrawerLayout
4.  @SuppressLint("...")
5.  @SuppressWarnings("deprecation")
6.  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
7.  CharSequence
8.  attr
9.  dimen
10.  @Nullable
11.  <merge>
12.  android:shadowDx
13.  android:shadowDy
14.  android:shadowRadius
15.  layout_alignWithParentIfMissing







### 双击返回键退出

```java
private long exitTime = 0;

@Override
   public boolean onKeyDown(int keyCode, KeyEvent event) {
       if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {
          //两秒之内按返回键就会退出
           if ((System.currentTimeMillis() - exitTime) > 2000) {
               Toast.makeText(getApplicationContext(), "再按一次退出程序", Toast.LENGTH_SHORT).show();
               exitTime = System.currentTimeMillis();
           } else {
               finish();
               System.exit(0);
           }
           return true;
       }
       return super.onKeyDown(keyCode, event);
   }
```

